using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class GameManager : MonoBehaviour
{
    public static GameManager Instance { get; private set; }

    [Header("Bullet Pool")]
    public GameObject bulletPrefab;
    public int poolSize = 200;
    public int maxActiveBullets = 100;
    public float bulletLifeTime = 0.2f;
    public bool expandPool = true; // allow Instantiate when pool empty

    [Header("AI Spawning")]
    public GameObject aiPrefab;
    public bool enableAISpawning = true;
    public float aiSpawnInterval = 5f;
    public float aiSpawnMinDistance = 12f; // min distance from player to spawn
    public float aiSpawnMaxDistance = 25f; // max distance from player to spawn
    public int maxAICount = 20;
    public int maxSpawnAttempts = 30;

    private Queue<GameObject> bulletPool = new Queue<GameObject>();
    private int activeBulletCount = 0;

    private List<GameObject> spawnedAIs = new List<GameObject>();

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(gameObject);

        InitPool();
    }

    private void Start()
    {
        if (enableAISpawning && aiPrefab != null)
        {
            StartCoroutine(AISpawnLoop());
        }
    }

    private void InitPool()
    {
        if (bulletPrefab == null) return;
        for (int i = 0; i < poolSize; i++)
        {
            GameObject go = Instantiate(bulletPrefab);
            go.SetActive(false);
            bulletPool.Enqueue(go);
        }
    }

    private IEnumerator AISpawnLoop()
    {
        while (true)
        {
            yield return new WaitForSeconds(aiSpawnInterval);

            // cleanup dead AIs
            spawnedAIs.RemoveAll(item => item == null);

            if (spawnedAIs.Count >= maxAICount) continue;

            GameObject player = GameObject.FindGameObjectWithTag("Player");
            if (player == null) continue;

            Camera cam = Camera.main;

            bool spawned = false;
            for (int attempt = 0; attempt < maxSpawnAttempts && !spawned; attempt++)
            {
                // pick random direction and distance
                float angle = Random.Range(0f, Mathf.PI * 2f);
                float dist = Random.Range(aiSpawnMinDistance, aiSpawnMaxDistance);
                Vector3 pos = player.transform.position + new Vector3(Mathf.Cos(angle), Mathf.Sin(angle), 0f) * dist;

                // ensure pos is outside camera viewport (if camera exists)
                if (cam != null)
                {
                    Vector3 vp = cam.WorldToViewportPoint(pos);
                    bool outsideView = vp.x < 0f || vp.x > 1f || vp.y < 0f || vp.y > 1f || vp.z < 0f;
                    if (!outsideView)
                    {
                        continue; // try another position
                    }
                }

                // instantiate AI prefab
                GameObject ai = Instantiate(aiPrefab, pos, Quaternion.identity);
                spawnedAIs.Add(ai);
                spawned = true;
            }
        }
    }

    private GameObject GetBulletFromPool()
    {
        if (bulletPool.Count > 0)
        {
            GameObject go = bulletPool.Dequeue();
            go.SetActive(true);
            return go;
        }

        if (expandPool)
        {
            GameObject go = Instantiate(bulletPrefab);
            go.SetActive(true);
            return go;
        }

        return null;
    }

    // owner is optional; passed to Bullet.Shoot so bullets can ignore collisions with owner if desired
    public bool TrySpawnBullet(Vector3 position, Vector2 velocity, GameObject owner = null)
    {
        if (bulletPrefab == null) return false;
        if (activeBulletCount >= maxActiveBullets) return false;

        GameObject go = GetBulletFromPool();
        if (go == null) return false;

        go.transform.position = position;
        go.transform.rotation = Quaternion.identity;

        Bullet bulletComp = go.GetComponent<Bullet>();
        activeBulletCount++;

        System.Action<GameObject> returnToPool = ReturnBullet;

        if (bulletComp != null)
        {
            bulletComp.Shoot(velocity, bulletLifeTime, owner, returnToPool);
        }
        else
        {
            Rigidbody2D rb = go.GetComponent<Rigidbody2D>();
            if (rb != null)
            {
                go.SetActive(true);
                rb.velocity = velocity;
                StartCoroutine(ReturnAfterLifetime(go, bulletLifeTime));
            }
            else
            {
                // nothing to move the bullet with; return it
                ReturnBullet(go);
                return false;
            }
        }

        return true;
    }

    private void ReturnBullet(GameObject go)
    {
        go.SetActive(false);
        bulletPool.Enqueue(go);
        activeBulletCount = Mathf.Max(0, activeBulletCount - 1);
    }

    private IEnumerator ReturnAfterLifetime(GameObject go, float lifetime)
    {
        yield return new WaitForSeconds(lifetime);
        ReturnBullet(go);
    }
}
