using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class GameManager : MonoBehaviour
{
 public static GameManager Instance { get; private set; }

 [Header("Bullet Pool")]
 public GameObject bulletPrefab;
 public int poolSize =200;
 public int maxActiveBullets =100;
 public float bulletLifeTime =0.2f;
 public bool expandPool = true; // allow Instantiate when pool empty

 private Queue<GameObject> bulletPool = new Queue<GameObject>();
 private int activeBulletCount =0;

 private void Awake()
 {
 if (Instance != null && Instance != this)
 {
 Destroy(gameObject);
 return;
 }
 Instance = this;
 DontDestroyOnLoad(gameObject);

 InitPool();
 }

 private void InitPool()
 {
 if (bulletPrefab == null) return;
 for (int i =0; i < poolSize; i++)
 {
 GameObject go = Instantiate(bulletPrefab);
 go.SetActive(false);
 bulletPool.Enqueue(go);
 }
 }

 private GameObject GetBulletFromPool()
 {
 if (bulletPool.Count >0)
 {
 GameObject go = bulletPool.Dequeue();
 go.SetActive(true);
 return go;
 }

 if (expandPool)
 {
 GameObject go = Instantiate(bulletPrefab);
 go.SetActive(true);
 return go;
 }

 return null;
 }

 public bool TrySpawnBullet(Vector3 position, Vector2 velocity)
 {
 if (bulletPrefab == null) return false;
 if (activeBulletCount >= maxActiveBullets) return false;

 GameObject go = GetBulletFromPool();
 if (go == null) return false;

 go.transform.position = position;
 go.transform.rotation = Quaternion.identity;

 Bullet bulletComp = go.GetComponent<Bullet>();
 activeBulletCount++;

 System.Action<GameObject> returnToPool = ReturnBullet;

 if (bulletComp != null)
 {
 bulletComp.Shoot(velocity, bulletLifeTime, returnToPool);
 }
 else
 {
 Rigidbody2D rb = go.GetComponent<Rigidbody2D>();
 if (rb != null)
 {
 go.SetActive(true);
 rb.velocity = velocity;
 StartCoroutine(ReturnAfterLifetime(go, bulletLifeTime));
 }
 else
 {
 // nothing to move the bullet with; return it
 ReturnBullet(go);
 return false;
 }
 }

 return true;
 }

 private void ReturnBullet(GameObject go)
 {
 go.SetActive(false);
 bulletPool.Enqueue(go);
 activeBulletCount = Mathf.Max(0, activeBulletCount -1);
 }

 private IEnumerator ReturnAfterLifetime(GameObject go, float lifetime)
 {
 yield return new WaitForSeconds(lifetime);
 ReturnBullet(go);
 }
}
